# -*- coding: utf-8 -*-
"""Slack Messaging module and for sending in-game messages to Slack."""

import logging
import re
import time
from pathlib import Path
from typing import Dict, List, Optional

from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from slack_sdk.web.slack_response import SlackResponse

from .mbox import Mbox


class SlackMessaging:
    """A class used to parse in-game messages and send them to Slack."""

    def __init__(
        self,
        slack_bot_token: str,
        slack_channel_id: str,
    ) -> None:
        """Class constructor."""
        super().__init__()
        self.slack_channel_id = slack_channel_id
        self.slack_client = WebClient(token=slack_bot_token)
        self.logger = logging.getLogger(__name__)

    def send_slack_message(
        self, text: str, sender: Dict, parent: Optional[str] = None
    ) -> SlackResponse:
        """Send Slack message to the configured channel."""
        try:
            icon = sender["icons"]["league"]
            if sender["icons"]["race"]:
                icon = sender["icons"]["race"]
            elif sender["icons"]["player"]:
                icon = sender["icons"]["player"]

            # Call the chat.postMessage method using the WebClient
            result = self.slack_client.chat_postMessage(
                channel=self.slack_channel_id,
                text=text,
                username=sender["name"],
                icon_url=icon,
                thread_ts=parent,
            )
            self.logger.debug(result)

            if parent:
                time.sleep(1)
                child_pl = self.slack_client.chat_getPermalink(
                    channel=self.slack_channel_id, message_ts=result["ts"]
                )
                text = f"<{child_pl['permalink']}|New message in thread>"
                channel_result = self.slack_client.chat_postMessage(
                    channel=self.slack_channel_id,
                    text=text,
                    username=sender["name"],
                    icon_url=icon,
                )
                self.logger.debug(channel_result)

            return result

        except SlackApiError as err:
            self.logger.error("Error posting message: %s", err)
            raise

    def send_new_messages_to_slack(
        self, messages: List, planets_game_id: str, mbox_path: Optional[Path] = None
    ) -> None:
        """Fetch messages from a game and send new ones to Slack."""
        if not mbox_path:
            mbox_path = Path(f"messages-{planets_game_id}.mbox")
        mbox = Mbox(mbox_path)
        message_ids = mbox.get_message_ids()

        for msg in messages:
            slack_thread_id = None
            # Check that we haven't sent the message earlier, and filter out
            # some spammy messages generated by the system.
            if msg["msgid"] not in message_ids:
                if not (
                    msg["sourcename"] == msg["gamename"]
                    and len(msg["replies"]) == 0
                    and re.search(
                        "joined the game in slot|earned the award", msg["message"]
                    )
                ):
                    # Let's not overwhelm Slack API
                    time.sleep(2)

                    # Construct the Slack message and send it
                    slack_resp = self.send_slack_message(
                        self.construct_slack_message(msg),
                        msg["sender"],
                    )

                    if slack_resp:
                        self.logger.info(
                            "Message %s sent to Slack successfully.", msg["msgid"]
                        )
                        slack_thread_id = slack_resp["ts"]
                        if mbox.save_email_message(msg, slack_thread_id):
                            message_ids[msg["msgid"]] = slack_thread_id
            else:
                self.logger.debug("Message %s already sent.", msg["msgid"])
                slack_thread_id = message_ids[msg["msgid"]]

            for reply in sorted(msg["replies"], key=lambda x: x["dateadded"]):
                if reply["msgid"] not in message_ids:
                    # Let's not overwhelm Slack API
                    time.sleep(2)

                    # Construct the Slack message and send it
                    slack_reply_resp = self.send_slack_message(
                        self.construct_slack_message(reply),
                        reply["sender"],
                        slack_thread_id,
                    )

                    if slack_reply_resp:
                        self.logger.info(
                            "Reply %s (parent %s) sent to Slack successfully.",
                            reply["msgid"],
                            msg["msgid"],
                        )
                        if mbox.save_email_message(reply, slack_reply_resp["ts"]):
                            message_ids[reply["msgid"]] = slack_thread_id
                else:
                    self.logger.debug(
                        "Reply %s (parent %s) already sent.",
                        reply["msgid"],
                        msg["msgid"],
                    )

    @staticmethod
    def construct_slack_message(message: Dict) -> str:
        """Construct a Slack message from an in-game message."""
        turn_str = f'*Turn {message["turn"]}*'
        to_str = f'*To:* {", ".join(message["recipients"].keys())}'
        date_str = f'*Date*: {message["dateadded"]}'
        body_str = message["message"].replace("<br/>", "\n")
        return f"{turn_str}\n{to_str}\n{date_str}\n\n{body_str}"
